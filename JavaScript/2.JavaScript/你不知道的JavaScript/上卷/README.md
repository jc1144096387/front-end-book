## 你不知道的javas下卷笔记

### 第一部分作用域和闭包
#### 第1章作用域是什么
##### 1.1编译原理
编译：分词/词法分析(Tokenizing/Lexing)、解析/语法分析(Parsing)、代码生成
分词/词法分析：将字符串分解成词法单元(token);分词通过无状态的方式识别词法单元，词法分析则通过有状态的方式。
解析/语法分析：将词法单元流（数组）转换成 抽象语法树（Abstract Syntax Tree, AST）
代码生成：将AST转化为可执行代码，如机器指令。
JavaScript引擎要复杂的多。例如，在语法分析和代码生成阶段有特定的步骤对运行性能进行优化。JIT
##### 1.2理解作用域
引擎：从头到尾负责整个 JavaScript 程序的编译及执行过程。
编译器：负责语法分析及代码生成等脏活累活
作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。
变量赋值操作(如var a = 2;)：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。
运行时引擎在作用域中查找变量的两种方式：LHS和RHS
LHS查询：查找变量的容器本身，从而可以对其赋值。如变量在赋值操作左侧时
RHS查询：查找变量的值。如console.log(a);

todo: 验证答案
小测验
            function foo(a){
                var b = a;
                return a + b;
            }
            var c = foo(2);
1.LHS 查找c
2.RHS 查找foo
3.LHS 查找a,把2赋值给a
4.LHS 查找b
5.RHS 查找a
6.RHS 查找a
7.RHS 查找b
todo: 以上种类数量正确，顺序待确定

##### 1.3作用域嵌套
遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。

##### 1.4异常
RHS：如果RHS查询在所有嵌套的作用域中都找不到所需变量，引擎就会抛出ReferenceError异常。
LHS：如果LHS查询在所有嵌套的作用域中都找不到所需变量，在非严格模式下，全局作用域中就会创建一个具有该名称的变量，并返回给引擎。在严格模式下，引擎就会抛出ReferenceError异常。（a = 2;）接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。

todo: 严格模式和非严格模式的区别
todo: 所有抛出ReferenceError和TypeError异常的情况,undefined和null的区别

##### 1.5总结
作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对
变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。                
赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域
的赋值操作。                
JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声
明会被分解成两个独立的步骤：            
1. 首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。
2. 接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。              
LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所
需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层
楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。                
不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式
地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛
出 ReferenceError 异常（严格模式下）。


#### 第2章词法作用域
作用域有两种主要的工作模型：词法作用域和动态作用域。                       
词法作用域最为普遍，JavaScript采用的就是词法作用域。     
简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。                          
无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。    

在运行时修改（欺骗）词法作用域：eval和with
不推荐使用eval和with的原因：会降低性能、在严格模式下会受影响。

词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。                                    
JavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。         
这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。

#### 第3章函数作用域和块作用域

#### 第4章提升
包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。          
当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个声明：var a; 和 a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。

#### 第5章作用域闭包
即使函数是在当前词法作用域之外执行，当函数可以记住并访问所在的词法作用域时，就产生了闭包。
简单来说，一个内部函数就是一个闭包，它能够访问外部函数的作用域。

模块模式：模块和模块暴露                
模块模式的两个必要条件              
1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块
实例）。
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并
且可以访问或者修改私有的状态。

// todo 深入模块机制写一篇博客，甚至造一个简单的轮子，可能需要先去了解各种模块加载包括ES6的模块机制


### 第二部分this和对象原型
#### 第1章关于this
对于那些没有投入时间学习 this 机制的 JavaScript 开发者来说，this 的绑定一直是一件非常令人困惑的事。this 是非常重要的，但是猜测、尝试并出错和盲目地从 Stack Overflow上复制和粘贴答案并不能让你真正理解 this 的机制。         
学习 this 的第一步是明白 this 既不指向函数自身也不指向函数的词法作用域，你也许被这样的解释误导过，但其实它们都是错误的。            
this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。       

#### 第2章this全面解析
##### 2.1调用位置
调用位置：调用位置就是函数在代码中被调用的位置，而不是声明的位置。
##### 2.2绑定规则
绑定规则：在函数的执行过程中调用位置如何决定 this 的绑定对象。有4种绑定规则。
默认绑定：在非严格模式下，this会被绑定到全局对象。在严格模式下，this会被绑定到undefined。
何时应用默认绑定：直接使用不带任何修饰的函数引用进行调用时，无法应用其他规则，因此只能使用默认绑定。如：独立函数调用
隐式绑定：当函数引用有上下文对象时，隐式绑定规则就会把函数调用中的this绑定到这个上下文对象。
隐式丢失：一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。
显式绑定：使用函数的call或apply方法来指定this的绑定对象
硬绑定：硬绑定是显式绑定的一个变种，可以解决绑定丢失问题。
new绑定：JavaScript中dnew机制与面向类的语言中的机制完全不同。JavaScript中的构造函数只是被new操作符调用的普通函数。
使用new调用函数会执行以下步骤：
- 创建（或者说构造）一个全新的对象。
- 这个新对象会被执行 [[ 原型 ]] 连接。
- 这个新对象会绑定到函数调用的 this。
- 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。

##### 2.3优先级
- 默认绑定优先级最低
- 显式绑定优先级高于隐式绑定
- new绑定优先级高于隐式绑定
- new绑定优先级高于显式绑定（从bind源码来看）
- 一般来说，判断this绑定，根据优先级可以按照以下顺序来判断：new绑定、显式绑定、隐式绑定、默认绑定

##### 2.4绑定例外
##### 2.5this词法
#### 第3章对象
#### 第4章混合对象“类”
#### 第5章原型
#### 第6章行为委托
